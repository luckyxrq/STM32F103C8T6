; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\pt-1.4 -I..\..\letter-shell\src -I.\RTE\_Flash -IC:\Users\ws\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\ws\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;88     */
;;;89     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  b108              CBZ      r0,|L1.6|
;;;90     {
;;;91     	if (_ucPort == COM1)
;;;92     	{
;;;93     		#if UART1_FIFO_EN == 1
;;;94     			return &g_tUart1;
;;;95     		#else
;;;96     			return 0;
;;;97     		#endif
;;;98     	}
;;;99     	else if (_ucPort == COM2)
;;;100    	{
;;;101    		#if UART2_FIFO_EN == 1
;;;102    			return &g_tUart2;
;;;103    		#else
;;;104    			return 0;
;;;105    		#endif
;;;106    	}
;;;107    	else if (_ucPort == COM3)
;;;108    	{
;;;109    		#if UART3_FIFO_EN == 1
;;;110    			return &g_tUart3;
;;;111    		#else
;;;112    			return 0;
;;;113    		#endif
;;;114    	}
;;;115    	else if (_ucPort == COM4)
;;;116    	{
;;;117    		#if UART4_FIFO_EN == 1
;;;118    			return &g_tUart4;
;;;119    		#else
;;;120    			return 0;
;;;121    		#endif
;;;122    	}
;;;123    	else if (_ucPort == COM5)
;;;124    	{
;;;125    		#if UART5_FIFO_EN == 1
;;;126    			return &g_tUart5;
;;;127    		#else
;;;128    			return 0;
;;;129    		#endif
;;;130    	}
;;;131    	else
;;;132    	{
;;;133    		/* 不做任何处理 */
;;;134    		return 0;
000002  2000              MOVS     r0,#0
;;;135    	}
;;;136    }
000004  4770              BX       lr
                  |L1.6|
000006  4801              LDR      r0,|L1.12|
000008  4770              BX       lr
;;;137    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      ||.bss||

                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;419    */
;;;420    static void InitHardUart(void)
000000  b510              PUSH     {r4,lr}
;;;421    {
000002  b086              SUB      sp,sp,#0x18
;;;422    	GPIO_InitTypeDef GPIO_InitStructure;
;;;423    	USART_InitTypeDef USART_InitStructure;
;;;424    
;;;425    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;426    
;;;427    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;428    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;429    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;430    
;;;431    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;432    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;433    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;434    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
;;;435    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  4c1a              LDR      r4,|L2.144|
000026  f88d0012          STRB     r0,[sp,#0x12]         ;434
00002a  a904              ADD      r1,sp,#0x10
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       GPIO_Init
;;;436    
;;;437    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;438    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;439    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;440    	*/
;;;441    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  1520              ASRS     r0,r4,#20
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;442    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;443    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       GPIO_Init
;;;444    	
;;;445    	/* 第4步： 配置串口硬件参数 */
;;;446    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000046  f44f30e1          MOV      r0,#0x1c200
;;;447    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004a  9000              STR      r0,[sp,#0]
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;448    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;449    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;450    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;451    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
;;;452    	USART_Init(USART1, &USART_InitStructure);
000060  4c0c              LDR      r4,|L2.148|
000062  f8ad000a          STRH     r0,[sp,#0xa]          ;451
000066  4669              MOV      r1,sp
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       USART_Init
;;;453    
;;;454    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00006e  2201              MOVS     r2,#1
000070  f2405125          MOV      r1,#0x525
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       USART_ITConfig
;;;455    	/*
;;;456    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;457    		注意: 不要在此处打开发送中断
;;;458    		发送中断使能在SendUart()函数打开
;;;459    	*/
;;;460    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
00007a  2101              MOVS     r1,#1
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       USART_Cmd
;;;461    
;;;462    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;463    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;464    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000082  2140              MOVS     r1,#0x40
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       USART_ClearFlag
;;;465    #endif
;;;466    
;;;467    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;468    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;469    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
;;;470    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;471    
;;;472    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;473    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;474    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;475    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;476    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;477    
;;;478    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;479    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;480    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;481    	*/
;;;482    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;483    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;484    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;485    	/*  第3步已经做了，因此这步可以不做
;;;486    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;487    	*/
;;;488    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;489    
;;;490    	/* 第4步： 配置串口硬件参数 */
;;;491    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
;;;492    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;493    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;494    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;495    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;496    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
;;;497    	USART_Init(USART2, &USART_InitStructure);
;;;498    
;;;499    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;500    	/*
;;;501    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;502    		注意: 不要在此处打开发送中断
;;;503    		发送中断使能在SendUart()函数打开
;;;504    	*/
;;;505    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
;;;506    
;;;507    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;508    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;509    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;510    #endif
;;;511    
;;;512    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;513    
;;;514    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;515    	{
;;;516    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;517    
;;;518    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;519    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;520    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;521    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;522    	}
;;;523    
;;;524    	/* 第1步： 开启GPIO和UART时钟 */
;;;525    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;526    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;527    
;;;528    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;529    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;530    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;531    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;532    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;533    
;;;534    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;535    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;536    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;537    	*/
;;;538    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;539    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;540    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;541    	/*  第3步已经做了，因此这步可以不做
;;;542    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;543    	*/
;;;544    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;545    
;;;546    	/* 第4步： 配置串口硬件参数 */
;;;547    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;548    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;549    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;550    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;551    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;552    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;553    	USART_Init(USART3, &USART_InitStructure);
;;;554    
;;;555    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;556    	/*
;;;557    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;558    		注意: 不要在此处打开发送中断
;;;559    		发送中断使能在SendUart()函数打开
;;;560    	*/
;;;561    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;562    
;;;563    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;564    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;565    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;566    #endif
;;;567    
;;;568    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;569    	/* 第1步： 开启GPIO和UART时钟 */
;;;570    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;571    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;572    
;;;573    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;574    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;575    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;576    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;577    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;578    
;;;579    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;580    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;581    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;582    	*/
;;;583    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;584    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;585    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;586    
;;;587    	/* 第4步： 配置串口硬件参数 */
;;;588    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;589    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;590    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;591    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;592    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;593    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;594    	USART_Init(UART4, &USART_InitStructure);
;;;595    
;;;596    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;597    	/*
;;;598    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;599    		注意: 不要在此处打开发送中断
;;;600    		发送中断使能在SendUart()函数打开
;;;601    	*/
;;;602    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;603    
;;;604    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;605    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;606    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;607    #endif
;;;608    
;;;609    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;610    	/* 第1步： 开启GPIO和UART时钟 */
;;;611    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;612    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;613    
;;;614    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;615    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;616    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;617    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;618    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;619    
;;;620    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;621    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;622    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;623    	*/
;;;624    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;625    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;626    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;627    
;;;628    
;;;629    	/* 第4步： 配置串口硬件参数 */
;;;630    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;631    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;632    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;633    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;634    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;635    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;636    	USART_Init(UART5, &USART_InitStructure);
;;;637    
;;;638    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;639    	/*
;;;640    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;641    		注意: 不要在此处打开发送中断
;;;642    		发送中断使能在SendUart()函数打开
;;;643    	*/
;;;644    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;645    
;;;646    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;647    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;648    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;649    #endif
;;;650    }
00008a  b006              ADD      sp,sp,#0x18
00008c  bd10              POP      {r4,pc}
;;;651    
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      0x40010800
                  |L2.148|
                          DCD      0x40013800

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;927    #if UART1_FIFO_EN == 1
;;;928    void USART1_IRQHandler(void)
000000  4801              LDR      r0,|L3.8|
;;;929    {
;;;930    	UartIRQ(&g_tUart1);
000002  f7ffbffe          B.W      UartIRQ
;;;931    }
;;;932    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;834    */
;;;835    static void UartIRQ(UART_T *_pUart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;836    {
000004  4604              MOV      r4,r0
;;;837    	/* 处理接收中断  */
;;;838    	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000006  6800              LDR      r0,[r0,#0]
000008  f2405125          MOV      r1,#0x525
00000c  f7fffffe          BL       USART_GetITStatus
000010  2500              MOVS     r5,#0
000012  b1b8              CBZ      r0,|L4.68|
;;;839    	{
;;;840    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;841    		uint8_t ch;
;;;842    
;;;843    		ch = USART_ReceiveData(_pUart->uart);
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       USART_ReceiveData
;;;844    		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
00001a  8ae2              LDRH     r2,[r4,#0x16]
00001c  68a1              LDR      r1,[r4,#8]
00001e  b2c0              UXTB     r0,r0                 ;843
000020  5488              STRB     r0,[r1,r2]
;;;845    		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
000022  8ae1              LDRH     r1,[r4,#0x16]
000024  1c49              ADDS     r1,r1,#1
000026  b28a              UXTH     r2,r1
000028  82e2              STRH     r2,[r4,#0x16]
00002a  89e1              LDRH     r1,[r4,#0xe]
00002c  428a              CMP      r2,r1
00002e  d300              BCC      |L4.50|
;;;846    		{
;;;847    			_pUart->usRxWrite = 0;
000030  82e5              STRH     r5,[r4,#0x16]
                  |L4.50|
;;;848    		}
;;;849    		if (_pUart->usRxCount < _pUart->usRxBufSize)
000032  8b62              LDRH     r2,[r4,#0x1a]
000034  428a              CMP      r2,r1
000036  d202              BCS      |L4.62|
;;;850    		{
;;;851    			_pUart->usRxCount++;
000038  8b61              LDRH     r1,[r4,#0x1a]
00003a  1c49              ADDS     r1,r1,#1
00003c  8361              STRH     r1,[r4,#0x1a]
                  |L4.62|
;;;852    		}
;;;853    
;;;854    		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;855    		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;856    		//if (_pUart->usRxCount == 1)
;;;857    		{
;;;858    			if (_pUart->ReciveNew)
00003e  6a61              LDR      r1,[r4,#0x24]
000040  b101              CBZ      r1,|L4.68|
;;;859    			{
;;;860    				_pUart->ReciveNew(ch);
000042  4788              BLX      r1
                  |L4.68|
;;;861    			}
;;;862    		}
;;;863    	}
;;;864    
;;;865    	/* 处理发送缓冲区空中断 */
;;;866    	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
000044  f2407727          MOV      r7,#0x727
000048  4639              MOV      r1,r7
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       USART_GetITStatus
;;;867    	{
;;;868    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;869    		if (_pUart->usTxCount == 0)
;;;870    		{
;;;871    			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;872    			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
;;;873    
;;;874    			/* 使能数据发送完毕中断 */
;;;875    			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000050  f2406626          MOV      r6,#0x626
000054  b190              CBZ      r0,|L4.124|
000056  8aa0              LDRH     r0,[r4,#0x14]         ;869
000058  b9c0              CBNZ     r0,|L4.140|
00005a  2200              MOVS     r2,#0                 ;872
00005c  4639              MOV      r1,r7                 ;872
00005e  6820              LDR      r0,[r4,#0]            ;872
000060  f7fffffe          BL       USART_ITConfig
000064  4631              MOV      r1,r6
000066  6820              LDR      r0,[r4,#0]
000068  e8bd41f0          POP      {r4-r8,lr}
00006c  2201              MOVS     r2,#1
00006e  f7ffbffe          B.W      USART_ITConfig
                  |L4.114|
;;;876    		}
;;;877    		else
;;;878    		{
;;;879    			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;880    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;881    			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
;;;882    			{
;;;883    				_pUart->usTxRead = 0;
;;;884    			}
;;;885    			_pUart->usTxCount--;
000072  8aa0              LDRH     r0,[r4,#0x14]
000074  1e40              SUBS     r0,r0,#1
000076  82a0              STRH     r0,[r4,#0x14]
                  |L4.120|
;;;886    		}
;;;887    
;;;888    	}
;;;889    	/* 数据bit位全部发送完毕的中断 */
;;;890    	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
;;;891    	{
;;;892    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;893    		if (_pUart->usTxCount == 0)
;;;894    		{
;;;895    			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;896    			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
;;;897    
;;;898    			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;899    			if (_pUart->SendOver)
;;;900    			{
;;;901    				_pUart->SendOver();
;;;902    			}
;;;903    		}
;;;904    		else
;;;905    		{
;;;906    			/* 正常情况下，不会进入此分支 */
;;;907    
;;;908    			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;909    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;910    			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
;;;911    			{
;;;912    				_pUart->usTxRead = 0;
;;;913    			}
;;;914    			_pUart->usTxCount--;
;;;915    		}
;;;916    	}
;;;917    }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L4.124|
00007c  4631              MOV      r1,r6                 ;890
00007e  6820              LDR      r0,[r4,#0]            ;890
000080  f7fffffe          BL       USART_GetITStatus
000084  2800              CMP      r0,#0                 ;890
000086  d0f7              BEQ      |L4.120|
000088  8aa0              LDRH     r0,[r4,#0x14]         ;893
00008a  b170              CBZ      r0,|L4.170|
                  |L4.140|
00008c  8a61              LDRH     r1,[r4,#0x12]         ;909
00008e  6860              LDR      r0,[r4,#4]            ;909
000090  5c41              LDRB     r1,[r0,r1]            ;909
000092  6820              LDR      r0,[r4,#0]            ;909
000094  f7fffffe          BL       USART_SendData
000098  8a60              LDRH     r0,[r4,#0x12]         ;910
00009a  1c40              ADDS     r0,r0,#1              ;910
00009c  b280              UXTH     r0,r0                 ;910
00009e  8260              STRH     r0,[r4,#0x12]         ;910
0000a0  89a1              LDRH     r1,[r4,#0xc]          ;910
0000a2  4288              CMP      r0,r1                 ;910
0000a4  d3e5              BCC      |L4.114|
0000a6  8265              STRH     r5,[r4,#0x12]         ;912
0000a8  e7e3              B        |L4.114|
                  |L4.170|
0000aa  2200              MOVS     r2,#0                 ;896
0000ac  4631              MOV      r1,r6                 ;896
0000ae  6820              LDR      r0,[r4,#0]            ;896
0000b0  f7fffffe          BL       USART_ITConfig
0000b4  6a20              LDR      r0,[r4,#0x20]         ;899
0000b6  2800              CMP      r0,#0                 ;899
0000b8  d0de              BEQ      |L4.120|
0000ba  e8bd41f0          POP      {r4-r8,lr}            ;901
0000be  4700              BX       r0                    ;901
;;;918    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;305    */
;;;306    static void UartVarInit(void)
000000  480c              LDR      r0,|L5.52|
;;;307    {
;;;308    #if UART1_FIFO_EN == 1
;;;309    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  490b              LDR      r1,|L5.48|
;;;310    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000004  6001              STR      r1,[r0,#0]  ; g_tUart1
000006  f1000128          ADD      r1,r0,#0x28
;;;311    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  6041              STR      r1,[r0,#4]  ; g_tUart1
00000c  f5006185          ADD      r1,r0,#0x428
;;;312    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000010  6081              STR      r1,[r0,#8]  ; g_tUart1
000012  f44f6180          MOV      r1,#0x400
000016  8181              STRH     r1,[r0,#0xc]
;;;313    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000018  81c1              STRH     r1,[r0,#0xe]
;;;314    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
00001a  2100              MOVS     r1,#0
00001c  8201              STRH     r1,[r0,#0x10]
;;;315    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001e  8241              STRH     r1,[r0,#0x12]
;;;316    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
000020  82c1              STRH     r1,[r0,#0x16]
;;;317    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000022  8301              STRH     r1,[r0,#0x18]
;;;318    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000024  8341              STRH     r1,[r0,#0x1a]
;;;319    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000026  8281              STRH     r1,[r0,#0x14]
;;;320    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;321    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000028  61c1              STR      r1,[r0,#0x1c]  ; g_tUart1
;;;322    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00002a  6201              STR      r1,[r0,#0x20]  ; g_tUart1
00002c  6241              STR      r1,[r0,#0x24]  ; g_tUart1
;;;323    #endif
;;;324    
;;;325    #if UART2_FIFO_EN == 1
;;;326    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
;;;327    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
;;;328    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
;;;329    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;330    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;331    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;332    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
;;;333    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;334    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
;;;335    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
;;;336    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
;;;337    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;338    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;339    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;340    #endif
;;;341    
;;;342    #if UART3_FIFO_EN == 1
;;;343    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;344    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;345    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;346    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;347    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;348    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;349    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;350    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;351    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;352    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;353    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;354    	g_tUart3.SendBefor = 0;		/* 发送数据前的回调函数 */
;;;355    	g_tUart3.SendOver = 0;			/* 发送完毕后的回调函数 */
;;;356    	g_tUart3.ReciveNew = 0;		/* 接收到新数据后的回调函数 */
;;;357    #endif
;;;358    
;;;359    #if UART4_FIFO_EN == 1
;;;360    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;361    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;362    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;363    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;364    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;365    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;366    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;367    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;368    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;369    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;370    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;371    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;372    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;373    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;374    #endif
;;;375    
;;;376    #if UART5_FIFO_EN == 1
;;;377    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;378    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;379    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;380    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;381    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;382    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;383    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;384    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;385    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;386    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;387    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;388    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;389    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;390    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;391    #endif
;;;392    
;;;393    
;;;394    #if UART6_FIFO_EN == 1
;;;395    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;396    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;397    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;398    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;399    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;400    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;401    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;402    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;403    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;404    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;405    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;406    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;407    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;408    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;409    #endif
;;;410    }
00002e  4770              BX       lr
;;;411    
                          ENDP

                  |L5.48|
                          DCD      0x40013800
                  |L5.52|
                          DCD      ||.bss||

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;70     */
;;;71     void bsp_InitUart(void)
000000  b508              PUSH     {r3,lr}
;;;72     {
;;;73     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;74     
;;;75     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
000010  2000              MOVS     r0,#0
000012  f88d0002          STRB     r0,[sp,#2]
000016  2001              MOVS     r0,#1
000018  f88d0003          STRB     r0,[sp,#3]
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       NVIC_Init
;;;76     
;;;77     
;;;78     	ConfigUartNVIC();	/* 配置串口中断 */
;;;79     }
000022  bd08              POP      {r3,pc}
;;;80     
                          ENDP


                          AREA ||i.bsp_SetUart1Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart1Baud PROC
;;;255    */
;;;256    void bsp_SetUart1Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;257    {
;;;258    	USART_InitTypeDef USART_InitStructure;
;;;259    
;;;260    	/* 第2步： 配置串口硬件参数 */
;;;261    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
;;;262    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;263    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;264    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;265    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;266    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;267    	USART_Init(USART2, &USART_InitStructure);
000002  4669              MOV      r1,sp
000004  9000              STR      r0,[sp,#0]            ;262
000006  2000              MOVS     r0,#0                 ;262
000008  f8ad0004          STRH     r0,[sp,#4]            ;262
00000c  f8ad0006          STRH     r0,[sp,#6]            ;263
000010  f8ad0008          STRH     r0,[sp,#8]            ;264
000014  f8ad000c          STRH     r0,[sp,#0xc]          ;265
000018  200c              MOVS     r0,#0xc               ;266
00001a  f8ad000a          STRH     r0,[sp,#0xa]          ;266
00001e  4802              LDR      r0,|L7.40|
000020  f7fffffe          BL       USART_Init
;;;268    }
000024  bd1f              POP      {r0-r4,pc}
;;;269    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart2Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart2Baud PROC
;;;277    */
;;;278    void bsp_SetUart2Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;279    {
;;;280    	USART_InitTypeDef USART_InitStructure;
;;;281    
;;;282    	/* 第2步： 配置串口硬件参数 */
;;;283    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
;;;284    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;285    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;286    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;287    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;288    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;289    	USART_Init(USART2, &USART_InitStructure);
000002  4669              MOV      r1,sp
000004  9000              STR      r0,[sp,#0]            ;284
000006  2000              MOVS     r0,#0                 ;284
000008  f8ad0004          STRH     r0,[sp,#4]            ;284
00000c  f8ad0006          STRH     r0,[sp,#6]            ;285
000010  f8ad0008          STRH     r0,[sp,#8]            ;286
000014  f8ad000c          STRH     r0,[sp,#0xc]          ;287
000018  200c              MOVS     r0,#0xc               ;288
00001a  f8ad000a          STRH     r0,[sp,#0xa]          ;288
00001e  4802              LDR      r0,|L8.40|
000020  f7fffffe          BL       USART_Init
;;;290    }
000024  bd1f              POP      {r0-r4,pc}
;;;291    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x40004400

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;232    */
;;;233    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;234    {
;;;235    	UART_T *pUart;
;;;236    
;;;237    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;238    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L9.18|
;;;239    	{
;;;240    		return;
;;;241    	}
;;;242    
;;;243    	pUart->usRxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  82c1              STRH     r1,[r0,#0x16]
;;;244    	pUart->usRxRead = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;245    	pUart->usRxCount = 0;
000010  8341              STRH     r1,[r0,#0x1a]
                  |L9.18|
;;;246    }
000012  bd00              POP      {pc}
;;;247    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;209    */
;;;210    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;211    {
;;;212    	UART_T *pUart;
;;;213    
;;;214    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;215    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L10.18|
;;;216    	{
;;;217    		return;
;;;218    	}
;;;219    
;;;220    	pUart->usTxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  8201              STRH     r1,[r0,#0x10]
;;;221    	pUart->usTxRead = 0;
00000e  8241              STRH     r1,[r0,#0x12]
;;;222    	pUart->usTxCount = 0;
000010  8281              STRH     r1,[r0,#0x14]
                  |L10.18|
;;;223    }
000012  bd00              POP      {pc}
;;;224    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;188    */
;;;189    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b510              PUSH     {r4,lr}
;;;190    {
;;;191    	UART_T *pUart;
;;;192    
;;;193    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;194    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d01f              BEQ      |L11.74|
;;;195    	{
;;;196    		return 0;
;;;197    	}
;;;198    
;;;199    	return UartGetChar(pUart, _pByte);
00000a  4602              MOV      r2,r0
00000c  2001              MOVS     r0,#1
00000e  f3808810          MSR      PRIMASK,r0
000012  8b53              LDRH     r3,[r2,#0x1a]
000014  2000              MOVS     r0,#0
000016  f3808810          MSR      PRIMASK,r0
00001a  2b00              CMP      r3,#0
00001c  d015              BEQ      |L11.74|
00001e  8b14              LDRH     r4,[r2,#0x18]
000020  6893              LDR      r3,[r2,#8]
000022  5d1b              LDRB     r3,[r3,r4]
000024  700b              STRB     r3,[r1,#0]
000026  2101              MOVS     r1,#1
000028  f3818810          MSR      PRIMASK,r1
00002c  8b11              LDRH     r1,[r2,#0x18]
00002e  1c49              ADDS     r1,r1,#1
000030  b289              UXTH     r1,r1
000032  8311              STRH     r1,[r2,#0x18]
000034  89d3              LDRH     r3,[r2,#0xe]
000036  4299              CMP      r1,r3
000038  d300              BCC      |L11.60|
00003a  8310              STRH     r0,[r2,#0x18]
                  |L11.60|
00003c  8b50              LDRH     r0,[r2,#0x1a]
00003e  1e40              SUBS     r0,r0,#1
000040  8350              STRH     r0,[r2,#0x1a]
000042  2000              MOVS     r0,#0
000044  f3808810          MSR      PRIMASK,r0
000048  2001              MOVS     r0,#1
                  |L11.74|
;;;200    }
00004a  bd10              POP      {r4,pc}
;;;201    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;147    */
;;;148    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;149    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;150    	UART_T *pUart;
;;;151    
;;;152    	pUart = ComToUart(_ucPort);
000006  f7fffffe          BL       ComToUart
00000a  0004              MOVS     r4,r0
;;;153    	if (pUart == 0)
00000c  d034              BEQ      |L12.120|
;;;154    	{
;;;155    		return;
;;;156    	}
;;;157    
;;;158    	if (pUart->SendBefor != 0)
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  b100              CBZ      r0,|L12.20|
;;;159    	{
;;;160    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
000012  4780              BLX      r0
                  |L12.20|
000014  2000              MOVS     r0,#0
;;;161    	}
;;;162    
;;;163    	UartSend(pUart, _ucaBuf, _usLen);
000016  e025              B        |L12.100|
                  |L12.24|
000018  89a1              LDRH     r1,[r4,#0xc]
                  |L12.26|
00001a  2201              MOVS     r2,#1
00001c  f3828810          MSR      PRIMASK,r2
000020  8aa2              LDRH     r2,[r4,#0x14]
000022  f8ad2000          STRH     r2,[sp,#0]
000026  2200              MOVS     r2,#0
000028  f3828810          MSR      PRIMASK,r2
00002c  f8bd2000          LDRH     r2,[sp,#0]
000030  4291              CMP      r1,r2
000032  d9f2              BLS      |L12.26|
000034  5c31              LDRB     r1,[r6,r0]
000036  8a23              LDRH     r3,[r4,#0x10]
000038  6862              LDR      r2,[r4,#4]
00003a  54d1              STRB     r1,[r2,r3]
00003c  2101              MOVS     r1,#1
00003e  f3818810          MSR      PRIMASK,r1
000042  8a21              LDRH     r1,[r4,#0x10]
000044  1c49              ADDS     r1,r1,#1
000046  b289              UXTH     r1,r1
000048  8221              STRH     r1,[r4,#0x10]
00004a  89a2              LDRH     r2,[r4,#0xc]
00004c  4291              CMP      r1,r2
00004e  d301              BCC      |L12.84|
000050  2100              MOVS     r1,#0
000052  8221              STRH     r1,[r4,#0x10]
                  |L12.84|
000054  8aa1              LDRH     r1,[r4,#0x14]
000056  1c49              ADDS     r1,r1,#1
000058  82a1              STRH     r1,[r4,#0x14]
00005a  2100              MOVS     r1,#0
00005c  f3818810          MSR      PRIMASK,r1
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
                  |L12.100|
000064  42a8              CMP      r0,r5
000066  d3d7              BCC      |L12.24|
000068  6820              LDR      r0,[r4,#0]
00006a  e8bd40f8          POP      {r3-r7,lr}
00006e  2201              MOVS     r2,#1
000070  f2407127          MOV      r1,#0x727
000074  f7ffbffe          B.W      USART_ITConfig
                  |L12.120|
;;;164    }
000078  bdf8              POP      {r3-r7,pc}
;;;165    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;174    */
;;;175    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;176    {
;;;177    	comSendBuf(_ucPort, &_ucByte, 1);
000002  2201              MOVS     r2,#1
000004  a901              ADD      r1,sp,#4
000006  f7fffffe          BL       comSendBuf
;;;178    }
00000a  bd1c              POP      {r2-r4,pc}
;;;179    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1002   */
;;;1003   int fgetc(FILE *f)
000000  b508              PUSH     {r3,lr}
                  |L14.2|
;;;1004   {
;;;1005   
;;;1006   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1007   	uint8_t ucData;
;;;1008   
;;;1009   	while(comGetChar(COM1, &ucData) == 0);
000002  4669              MOV      r1,sp
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       comGetChar
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L14.2|
;;;1010   
;;;1011   	return ucData;
00000e  f89d0000          LDRB     r0,[sp,#0]
;;;1012   #else
;;;1013   	/* 等待串口1输入数据 */
;;;1014   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1015   
;;;1016   	return (int)USART_ReceiveData(USART1);
;;;1017   #endif
;;;1018   }
000012  bd08              POP      {r3,pc}
;;;1019   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;976    */
;;;977    int fputc(int ch, FILE *f)
000000  b510              PUSH     {r4,lr}
;;;978    {
000002  4604              MOV      r4,r0
;;;979    #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;980    	comSendChar(COM1, ch);
000004  b2c1              UXTB     r1,r0
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       comSendChar
;;;981    
;;;982    	return ch;
00000c  4620              MOV      r0,r4
;;;983    #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;984    	/* 写一个字节到USART1 */
;;;985    	USART_SendData(USART1, (uint8_t) ch);
;;;986    
;;;987    	/* 等待发送结束 */
;;;988    	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;989    	{}
;;;990    
;;;991    	return ch;
;;;992    #endif
;;;993    }
00000e  bd10              POP      {r4,pc}
;;;994    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
