; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\pt-1.4 -I.\RTE\_Flash -IC:\Users\ws\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\ws\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.4.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=536 -D_RTE_ -DSTM32F10X_MD -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\flash\obj\bsp_spi_flash.crf ..\..\User\bsp\src\bsp_spi_flash.c]
                          THUMB

                          AREA ||i.bsp_InitSFlash||, CODE, READONLY, ALIGN=2

                  bsp_InitSFlash PROC
;;;161    */
;;;162    void bsp_InitSFlash(void)
000000  b538              PUSH     {r3-r5,lr}
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       sf_SetCS
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
00001c  f44f6000          MOV      r0,#0x800
000020  f8ad0000          STRH     r0,[sp,#0]
000024  4669              MOV      r1,sp
000026  4816              LDR      r0,|L1.128|
000028  f7fffffe          BL       GPIO_Init
;;;163    {
;;;164    	sf_ConfigGPIO();			/* 配置GPIO */
;;;165    	
;;;166    	//sf_CfgSpiHard();
;;;167    
;;;168    	sf_ReadInfo();				/* 自动识别芯片型号 */
00002c  f7fffffe          BL       sf_ReadInfo
;;;169    
;;;170    	sf_SetCS(0);				/* 软件方式，使能串行Flash片选 */
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       sf_SetCS
;;;171    	bsp_spiWrite1(CMD_DISWR);		/* 发送禁止写入的命令,即使能软件写保护 */
000036  2004              MOVS     r0,#4
000038  f7fffffe          BL       bsp_spiWrite1
;;;172    	sf_SetCS(1);				/* 软件方式，禁能串行Flash片选 */
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       sf_SetCS
;;;173    
;;;174    	sf_WaitForWriteEnd();		/* 等待串行Flash内部操作完成 */
000042  f7fffffe          BL       sf_WaitForWriteEnd
000046  480f              LDR      r0,|L1.132|
000048  490f              LDR      r1,|L1.136|
;;;175    
;;;176    	sf_WriteStatus(0);			/* 解除所有BLOCK的写保护 */
00004a  2400              MOVS     r4,#0
00004c  6800              LDR      r0,[r0,#0]  ; g_tSF
00004e  4288              CMP      r0,r1
000050  d108              BNE      |L1.100|
000052  2000              MOVS     r0,#0
000054  f7fffffe          BL       sf_SetCS
000058  2050              MOVS     r0,#0x50
00005a  f7fffffe          BL       bsp_spiWrite1
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       sf_SetCS
                  |L1.100|
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       sf_SetCS
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       bsp_spiWrite1
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       bsp_spiWrite1
000076  e8bd4038          POP      {r3-r5,lr}
00007a  2001              MOVS     r0,#1
00007c  f7ffbffe          B.W      sf_SetCS
;;;177    }
;;;178    
                          ENDP

                  |L1.128|
                          DCD      0x40011c00
                  |L1.132|
                          DCD      ||.bss||
                  |L1.136|
                          DCD      0x00bf2541

                          AREA ||i.sf_AutoWritePage||, CODE, READONLY, ALIGN=2

                  sf_AutoWritePage PROC
;;;437    */
;;;438    static uint8_t sf_AutoWritePage(uint8_t *_ucpSrc, uint32_t _uiWrAddr, uint16_t _usWrLen)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;439    {
000004  f5ad5d82          SUB      sp,sp,#0x1040
000008  460d              MOV      r5,r1
00000a  4683              MOV      r11,r0
00000c  0014              MOVS     r4,r2
00000e  d01d              BEQ      |L2.76|
;;;440    	uint16_t i;
;;;441    	uint16_t j;					/* 用于延时 */
;;;442    	uint32_t uiFirstAddr;		/* 扇区首址 */
;;;443    	uint8_t ucNeedErase;		/* 1表示需要擦除 */
;;;444    	uint8_t cRet;
;;;445    	uint8_t s_spiBuf[4*1024];	/* 用于写函数，先读出整个page，修改缓冲区后，再整个page回写 */	
;;;446    
;;;447    	/* 长度为0时不继续操作,直接认为成功 */
;;;448    	if (_usWrLen == 0)
;;;449    	{
;;;450    		return 1;
;;;451    	}
;;;452    
;;;453    	/* 如果偏移地址超过芯片容量则退出 */
;;;454    	if (_uiWrAddr >= g_tSF.TotalSize)
000010  483d              LDR      r0,|L2.264|
000012  6941              LDR      r1,[r0,#0x14]  ; g_tSF
000014  42a9              CMP      r1,r5
000016  d903              BLS      |L2.32|
;;;455    	{
;;;456    		return 0;
;;;457    	}
;;;458    
;;;459    	/* 如果数据长度大于扇区容量，则退出 */
;;;460    	if (_usWrLen > g_tSF.PageSize)
000018  4682              MOV      r10,r0
00001a  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
00001c  42a0              CMP      r0,r4
00001e  d204              BCS      |L2.42|
                  |L2.32|
;;;461    	{
;;;462    		return 0;
000020  2000              MOVS     r0,#0
                  |L2.34|
;;;463    	}
;;;464    
;;;465    	/* 如果FLASH中的数据没有变化,则不写FLASH */
;;;466    	sf_ReadBuffer(s_spiBuf, _uiWrAddr, _usWrLen);
;;;467    	if (memcmp(s_spiBuf, _ucpSrc, _usWrLen) == 0)
;;;468    	{
;;;469    		return 1;
;;;470    	}
;;;471    
;;;472    	/* 判断是否需要先擦除扇区 */
;;;473    	/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;474    	ucNeedErase = 0;
;;;475    	if (sf_NeedErase(s_spiBuf, _ucpSrc, _usWrLen))
;;;476    	{
;;;477    		ucNeedErase = 1;
;;;478    	}
;;;479    
;;;480    	uiFirstAddr = _uiWrAddr & (~(g_tSF.PageSize - 1));
;;;481    
;;;482    	if (_usWrLen == g_tSF.PageSize)		/* 整个扇区都改写 */
;;;483    	{
;;;484    		for	(i = 0; i < g_tSF.PageSize; i++)
;;;485    		{
;;;486    			s_spiBuf[i] = _ucpSrc[i];
;;;487    		}
;;;488    	}
;;;489    	else						/* 改写部分数据 */
;;;490    	{
;;;491    		/* 先将整个扇区的数据读出 */
;;;492    		sf_ReadBuffer(s_spiBuf, uiFirstAddr, g_tSF.PageSize);
;;;493    
;;;494    		/* 再用新数据覆盖 */
;;;495    		i = _uiWrAddr & (g_tSF.PageSize - 1);
;;;496    		memcpy(&s_spiBuf[i], _ucpSrc, _usWrLen);
;;;497    	}
;;;498    
;;;499    	/* 写完之后进行校验，如果不正确则重写，最多3次 */
;;;500    	cRet = 0;
;;;501    	for (i = 0; i < 3; i++)
;;;502    	{
;;;503    
;;;504    		/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;505    		if (ucNeedErase == 1)
;;;506    		{
;;;507    			sf_EraseSector(uiFirstAddr);		/* 擦除1个扇区 */
;;;508    		}
;;;509    
;;;510    		/* 编程一个PAGE */
;;;511    		sf_PageWrite(s_spiBuf, uiFirstAddr, g_tSF.PageSize);
;;;512    
;;;513    		if (sf_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;514    		{
;;;515    			cRet = 1;
;;;516    			break;
;;;517    		}
;;;518    		else
;;;519    		{
;;;520    			if (sf_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;521    			{
;;;522    				cRet = 1;
;;;523    				break;
;;;524    			}
;;;525    
;;;526    			/* 失败后延迟一段时间再重试 */
;;;527    			for (j = 0; j < 10000; j++);
;;;528    		}
;;;529    	}
;;;530    
;;;531    	return cRet;
;;;532    }
000022  f50d5d82          ADD      sp,sp,#0x1040
000026  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.42|
00002a  ae01              ADD      r6,sp,#4              ;466
00002c  4629              MOV      r1,r5                 ;466
00002e  4630              MOV      r0,r6                 ;466
000030  f7fffffe          BL       sf_ReadBuffer
000034  4622              MOV      r2,r4                 ;467
000036  4659              MOV      r1,r11                ;467
000038  4630              MOV      r0,r6                 ;467
00003a  f7fffffe          BL       memcmp
00003e  b128              CBZ      r0,|L2.76|
000040  2700              MOVS     r7,#0                 ;474
000042  46b0              MOV      r8,r6                 ;475
000044  4630              MOV      r0,r6                 ;475
000046  4659              MOV      r1,r11                ;475
000048  463a              MOV      r2,r7                 ;475
00004a  e00d              B        |L2.104|
                  |L2.76|
00004c  2001              MOVS     r0,#1                 ;469
00004e  e7e8              B        |L2.34|
                  |L2.80|
000050  f8103b01          LDRB     r3,[r0],#1
000054  f8116b01          LDRB     r6,[r1],#1
000058  43db              MVNS     r3,r3
00005a  b2db              UXTB     r3,r3
00005c  421e              TST      r6,r3
00005e  d001              BEQ      |L2.100|
000060  2701              MOVS     r7,#1                 ;477
000062  e003              B        |L2.108|
                  |L2.100|
000064  1c52              ADDS     r2,r2,#1              ;477
000066  b292              UXTH     r2,r2                 ;477
                  |L2.104|
000068  42a2              CMP      r2,r4                 ;477
00006a  d3f1              BCC      |L2.80|
                  |L2.108|
00006c  f8ba2018          LDRH     r2,[r10,#0x18]        ;480  ; g_tSF
000070  1e51              SUBS     r1,r2,#1              ;480
000072  ea250001          BIC      r0,r5,r1              ;480
000076  9000              STR      r0,[sp,#0]            ;482
000078  42a2              CMP      r2,r4                 ;482
00007a  d10b              BNE      |L2.148|
00007c  2000              MOVS     r0,#0                 ;484
00007e  4641              MOV      r1,r8                 ;445
000080  e005              B        |L2.142|
000082  bf00              NOP                            ;486
                  |L2.132|
000084  f81b3000          LDRB     r3,[r11,r0]           ;486
000088  540b              STRB     r3,[r1,r0]            ;486
00008a  1c40              ADDS     r0,r0,#1              ;486
00008c  b280              UXTH     r0,r0                 ;484
                  |L2.142|
00008e  4282              CMP      r2,r0                 ;484
000090  d8f8              BHI      |L2.132|
000092  e00e              B        |L2.178|
                  |L2.148|
000094  4601              MOV      r1,r0                 ;492
000096  4646              MOV      r6,r8                 ;492
000098  4640              MOV      r0,r8                 ;492
00009a  f7fffffe          BL       sf_ReadBuffer
00009e  f8ba0018          LDRH     r0,[r10,#0x18]        ;495  ; g_tSF
0000a2  4622              MOV      r2,r4                 ;496
0000a4  1e40              SUBS     r0,r0,#1              ;495
0000a6  4028              ANDS     r0,r0,r5              ;495
0000a8  b280              UXTH     r0,r0                 ;495
0000aa  4430              ADD      r0,r0,r6              ;496
0000ac  4659              MOV      r1,r11                ;496
0000ae  f7fffffe          BL       __aeabi_memcpy
                  |L2.178|
0000b2  2600              MOVS     r6,#0                 ;500
0000b4  46b1              MOV      r9,r6                 ;501
0000b6  f2427810          MOV      r8,#0x2710            ;527
                  |L2.186|
0000ba  b117              CBZ      r7,|L2.194|
0000bc  9800              LDR      r0,[sp,#0]            ;507
0000be  f7fffffe          BL       sf_EraseSector
                  |L2.194|
0000c2  f8ba2018          LDRH     r2,[r10,#0x18]        ;511  ; g_tSF
0000c6  a801              ADD      r0,sp,#4              ;511
0000c8  9900              LDR      r1,[sp,#0]            ;511
0000ca  f7fffffe          BL       sf_PageWrite
0000ce  4622              MOV      r2,r4                 ;513
0000d0  4659              MOV      r1,r11                ;513
0000d2  4628              MOV      r0,r5                 ;513
0000d4  f7fffffe          BL       sf_CmpData
0000d8  b1a0              CBZ      r0,|L2.260|
0000da  4622              MOV      r2,r4                 ;520
0000dc  4659              MOV      r1,r11                ;520
0000de  4628              MOV      r0,r5                 ;520
0000e0  f7fffffe          BL       sf_CmpData
0000e4  b170              CBZ      r0,|L2.260|
0000e6  2000              MOVS     r0,#0                 ;527
0000e8  4641              MOV      r1,r8                 ;527
                  |L2.234|
0000ea  1c40              ADDS     r0,r0,#1              ;527
0000ec  b280              UXTH     r0,r0                 ;527
0000ee  4288              CMP      r0,r1                 ;527
0000f0  d3fb              BCC      |L2.234|
0000f2  f1090001          ADD      r0,r9,#1              ;501
0000f6  fa1ff980          UXTH     r9,r0                 ;501
0000fa  f1b90f03          CMP      r9,#3                 ;501
0000fe  d3dc              BCC      |L2.186|
                  |L2.256|
000100  4630              MOV      r0,r6                 ;531
000102  e78e              B        |L2.34|
                  |L2.260|
000104  2601              MOVS     r6,#1                 ;515
000106  e7fb              B        |L2.256|
;;;533    
                          ENDP

                  |L2.264|
                          DCD      ||.bss||

                          AREA ||i.sf_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  sf_CfgSpiHard PROC
;;;93     */
;;;94     void sf_CfgSpiHard(void)
000000  b510              PUSH     {r4,lr}
;;;95     {
000002  b086              SUB      sp,sp,#0x18
;;;96     	SPI_InitTypeDef  SPI_InitStructure;
;;;97     
;;;98     	/* 配置SPI硬件参数 */
;;;99     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;100    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7182          MOV      r1,#0x104
00000e  f8ad1002          STRH     r1,[sp,#2]
;;;101    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  f8ad0004          STRH     r0,[sp,#4]
;;;102    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;103    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;104    	*/
;;;105    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000016  2102              MOVS     r1,#2
000018  f8ad1006          STRH     r1,[sp,#6]
;;;106    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001c  2101              MOVS     r1,#1
00001e  f8ad1008          STRH     r1,[sp,#8]
;;;107    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000022  0249              LSLS     r1,r1,#9
000024  f8ad100a          STRH     r1,[sp,#0xa]
;;;108    
;;;109    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_8 ，实测SCK周期 96ns, 10.4MHz */
;;;110    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
000028  2110              MOVS     r1,#0x10
00002a  f8ad100c          STRH     r1,[sp,#0xc]
;;;111    
;;;112    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
00002e  f8ad000e          STRH     r0,[sp,#0xe]
;;;113    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000032  2007              MOVS     r0,#7
;;;114    	SPI_Init(SPI1, &SPI_InitStructure);
000034  4c06              LDR      r4,|L3.80|
000036  f8ad0010          STRH     r0,[sp,#0x10]         ;113
00003a  4669              MOV      r1,sp
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SPI_Init
;;;115    
;;;116    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000042  2101              MOVS     r1,#1
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Cmd
;;;117    }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd10              POP      {r4,pc}
;;;118    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0x40013000

                          AREA ||i.sf_CmpData||, CODE, READONLY, ALIGN=2

                  sf_CmpData PROC
;;;349    */
;;;350    static uint8_t sf_CmpData(uint32_t _uiSrcAddr, uint8_t *_ucpTar, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;351    {
000002  460e              MOV      r6,r1
;;;352    	uint8_t ucValue;
;;;353    
;;;354    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;355    	if ((_uiSrcAddr + _uiSize) > g_tSF.TotalSize)
000004  4916              LDR      r1,|L4.96|
000006  4614              MOV      r4,r2                 ;351
000008  4605              MOV      r5,r0                 ;351
00000a  6949              LDR      r1,[r1,#0x14]  ; g_tSF
00000c  4420              ADD      r0,r0,r4
00000e  4288              CMP      r0,r1
000010  d901              BLS      |L4.22|
                  |L4.18|
;;;356    	{
;;;357    		return 1;
000012  2001              MOVS     r0,#1
;;;358    	}
;;;359    
;;;360    	if (_uiSize == 0)
;;;361    	{
;;;362    		return 0;
;;;363    	}
;;;364    
;;;365    	sf_SetCS(0);									/* 使能片选 */
;;;366    	bsp_spiWrite1(CMD_READ);							/* 发送读命令 */
;;;367    	bsp_spiWrite1((_uiSrcAddr & 0xFF0000) >> 16);		/* 发送扇区地址的高8bit */
;;;368    	bsp_spiWrite1((_uiSrcAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;369    	bsp_spiWrite1(_uiSrcAddr & 0xFF);					/* 发送扇区地址低8bit */
;;;370    	while (_uiSize--)
;;;371    	{
;;;372    		/* 读一个字节 */
;;;373    		ucValue = bsp_spiRead1();
;;;374    		if (*_ucpTar++ != ucValue)
;;;375    		{
;;;376    			sf_SetCS(1);
;;;377    			return 1;
;;;378    		}
;;;379    	}
;;;380    	sf_SetCS(1);
;;;381    	return 0;
;;;382    }
000014  bd70              POP      {r4-r6,pc}
                  |L4.22|
000016  b18c              CBZ      r4,|L4.60|
000018  2000              MOVS     r0,#0                 ;365
00001a  f7fffffe          BL       sf_SetCS
00001e  2003              MOVS     r0,#3                 ;366
000020  f7fffffe          BL       bsp_spiWrite1
000024  f3c54007          UBFX     r0,r5,#16,#8          ;367
000028  f7fffffe          BL       bsp_spiWrite1
00002c  f3c52007          UBFX     r0,r5,#8,#8           ;368
000030  f7fffffe          BL       bsp_spiWrite1
000034  b2e8              UXTB     r0,r5                 ;369
000036  f7fffffe          BL       bsp_spiWrite1
00003a  e00b              B        |L4.84|
                  |L4.60|
00003c  2000              MOVS     r0,#0                 ;362
00003e  bd70              POP      {r4-r6,pc}
                  |L4.64|
000040  f7fffffe          BL       bsp_spiRead1
000044  f8161b01          LDRB     r1,[r6],#1            ;374
000048  4281              CMP      r1,r0                 ;374
00004a  d003              BEQ      |L4.84|
00004c  2001              MOVS     r0,#1                 ;376
00004e  f7fffffe          BL       sf_SetCS
000052  e7de              B        |L4.18|
                  |L4.84|
000054  1e64              SUBS     r4,r4,#1              ;377
000056  d2f3              BCS      |L4.64|
000058  2001              MOVS     r0,#1                 ;380
00005a  f7fffffe          BL       sf_SetCS
00005e  e7ed              B        |L4.60|
;;;383    
                          ENDP

                  |L4.96|
                          DCD      ||.bss||

                          AREA ||i.sf_EraseChip||, CODE, READONLY, ALIGN=1

                  sf_EraseChip PROC
;;;209    */
;;;210    void sf_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212    	sf_WriteEnable();								/* 发送写使能命令 */
000002  f7fffffe          BL       sf_WriteEnable
;;;213    
;;;214    	/* 擦除扇区操作 */
;;;215    	sf_SetCS(0);									/* 使能片选 */
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       sf_SetCS
;;;216    	bsp_spiWrite1(CMD_BE);							/* 发送整片擦除命令 */
00000c  20c7              MOVS     r0,#0xc7
00000e  f7fffffe          BL       bsp_spiWrite1
;;;217    	sf_SetCS(1);									/* 禁能片选 */
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       sf_SetCS
;;;218    
;;;219    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      sf_WaitForWriteEnd
;;;220    }
;;;221    
                          ENDP


                          AREA ||i.sf_EraseSector||, CODE, READONLY, ALIGN=1

                  sf_EraseSector PROC
;;;186    */
;;;187    void sf_EraseSector(uint32_t _uiSectorAddr)
000000  b510              PUSH     {r4,lr}
;;;188    {
000002  4604              MOV      r4,r0
;;;189    	sf_WriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       sf_WriteEnable
;;;190    
;;;191    	/* 擦除扇区操作 */
;;;192    	sf_SetCS(0);									/* 使能片选 */
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       sf_SetCS
;;;193    	bsp_spiWrite1(CMD_SE);								/* 发送擦除命令 */
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       bsp_spiWrite1
;;;194    	bsp_spiWrite1((_uiSectorAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000014  f3c44007          UBFX     r0,r4,#16,#8
000018  f7fffffe          BL       bsp_spiWrite1
;;;195    	bsp_spiWrite1((_uiSectorAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
00001c  f3c42007          UBFX     r0,r4,#8,#8
000020  f7fffffe          BL       bsp_spiWrite1
;;;196    	bsp_spiWrite1(_uiSectorAddr & 0xFF);				/* 发送扇区地址低8bit */
000024  b2e0              UXTB     r0,r4
000026  f7fffffe          BL       bsp_spiWrite1
;;;197    	sf_SetCS(1);									/* 禁能片选 */
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       sf_SetCS
;;;198    
;;;199    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000030  e8bd4010          POP      {r4,lr}
000034  f7ffbffe          B.W      sf_WaitForWriteEnd
;;;200    }
;;;201    
                          ENDP


                          AREA ||i.sf_PageWrite||, CODE, READONLY, ALIGN=2

                  sf_PageWrite PROC
;;;231    */
;;;232    void sf_PageWrite(uint8_t * _pBuf, uint32_t _uiWriteAddr, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;233    {
000004  4604              MOV      r4,r0
;;;234    	uint32_t i, j;
;;;235    
;;;236    	if (g_tSF.ChipID == SST25VF016B_ID)
000006  483f              LDR      r0,|L7.260|
000008  460d              MOV      r5,r1                 ;233
00000a  493f              LDR      r1,|L7.264|
00000c  6800              LDR      r0,[r0,#0]  ; g_tSF
00000e  4616              MOV      r6,r2                 ;233
000010  4288              CMP      r0,r1
000012  d13d              BNE      |L7.144|
;;;237    	{
;;;238    		/* AAI指令要求传入的数据个数是偶数 */
;;;239    		if ((_usSize < 2) && (_usSize % 2))
000014  2e02              CMP      r6,#2
000016  d201              BCS      |L7.28|
000018  07f0              LSLS     r0,r6,#31
00001a  d171              BNE      |L7.256|
                  |L7.28|
;;;240    		{
;;;241    			return ;
;;;242    		}
;;;243    
;;;244    		sf_WriteEnable();								/* 发送写使能命令 */
00001c  f7fffffe          BL       sf_WriteEnable
;;;245    
;;;246    		sf_SetCS(0);									/* 使能片选 */
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       sf_SetCS
;;;247    		bsp_spiWrite1(CMD_AAI);							/* 发送AAI命令(地址自动增加编程) */
000026  20ad              MOVS     r0,#0xad
000028  f7fffffe          BL       bsp_spiWrite1
;;;248    		bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
00002c  f3c54007          UBFX     r0,r5,#16,#8
000030  f7fffffe          BL       bsp_spiWrite1
;;;249    		bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000034  f3c52007          UBFX     r0,r5,#8,#8
000038  f7fffffe          BL       bsp_spiWrite1
;;;250    		bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
00003c  b2e8              UXTB     r0,r5
00003e  f7fffffe          BL       bsp_spiWrite1
;;;251    		bsp_spiWrite1(*_pBuf++);							/* 发送第1个数据 */
000042  7820              LDRB     r0,[r4,#0]
000044  f7fffffe          BL       bsp_spiWrite1
;;;252    		bsp_spiWrite1(*_pBuf++);							/* 发送第2个数据 */
000048  7860              LDRB     r0,[r4,#1]
00004a  1ca4              ADDS     r4,r4,#2
00004c  f7fffffe          BL       bsp_spiWrite1
;;;253    		sf_SetCS(1);									/* 禁能片选 */
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       sf_SetCS
;;;254    
;;;255    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000056  f7fffffe          BL       sf_WaitForWriteEnd
00005a  1eb6              SUBS     r6,r6,#2
;;;256    
;;;257    		_usSize -= 2;									/* 计算剩余字节数 */
00005c  b2b6              UXTH     r6,r6
;;;258    
;;;259    		for (i = 0; i < _usSize / 2; i++)
00005e  2500              MOVS     r5,#0
000060  e012              B        |L7.136|
                  |L7.98|
;;;260    		{
;;;261    			sf_SetCS(0);								/* 使能片选 */
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       sf_SetCS
;;;262    			bsp_spiWrite1(CMD_AAI);						/* 发送AAI命令(地址自动增加编程) */
000068  20ad              MOVS     r0,#0xad
00006a  f7fffffe          BL       bsp_spiWrite1
;;;263    			bsp_spiWrite1(*_pBuf++);						/* 发送数据 */
00006e  7820              LDRB     r0,[r4,#0]
000070  f7fffffe          BL       bsp_spiWrite1
;;;264    			bsp_spiWrite1(*_pBuf++);						/* 发送数据 */
000074  7860              LDRB     r0,[r4,#1]
000076  1ca4              ADDS     r4,r4,#2
000078  f7fffffe          BL       bsp_spiWrite1
;;;265    			sf_SetCS(1);								/* 禁能片选 */
00007c  2001              MOVS     r0,#1
00007e  f7fffffe          BL       sf_SetCS
;;;266    			sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
000082  f7fffffe          BL       sf_WaitForWriteEnd
000086  1c6d              ADDS     r5,r5,#1
                  |L7.136|
000088  ebb50f56          CMP      r5,r6,LSR #1          ;259
00008c  d3e9              BCC      |L7.98|
00008e  e02a              B        |L7.230|
                  |L7.144|
;;;267    		}
;;;268    
;;;269    		/* 进入写保护状态 */
;;;270    		sf_SetCS(0);
;;;271    		bsp_spiWrite1(CMD_DISWR);
;;;272    		sf_SetCS(1);
;;;273    
;;;274    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;275    	}
;;;276    	else	/* for MX25L1606E 、 W25Q64BV */
;;;277    	{
;;;278    		for (j = 0; j < _usSize / 256; j++)
000090  f04f0800          MOV      r8,#0
000094  e024              B        |L7.224|
;;;279    		{
;;;280    			sf_WriteEnable();								/* 发送写使能命令 */
000096  bf00              NOP      
                  |L7.152|
000098  f7fffffe          BL       sf_WriteEnable
;;;281    
;;;282    			sf_SetCS(0);									/* 使能片选 */
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       sf_SetCS
;;;283    			bsp_spiWrite1(0x02);								/* 发送AAI命令(地址自动增加编程) */
0000a2  2002              MOVS     r0,#2
0000a4  f7fffffe          BL       bsp_spiWrite1
;;;284    			bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
0000a8  f3c54007          UBFX     r0,r5,#16,#8
0000ac  f7fffffe          BL       bsp_spiWrite1
;;;285    			bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
0000b0  f3c52007          UBFX     r0,r5,#8,#8
0000b4  f7fffffe          BL       bsp_spiWrite1
;;;286    			bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
0000b8  b2e8              UXTB     r0,r5
0000ba  f7fffffe          BL       bsp_spiWrite1
;;;287    
;;;288    			for (i = 0; i < 256; i++)
0000be  2700              MOVS     r7,#0
                  |L7.192|
;;;289    			{
;;;290    				bsp_spiWrite1(*_pBuf++);					/* 发送数据 */
0000c0  f8140b01          LDRB     r0,[r4],#1
0000c4  f7fffffe          BL       bsp_spiWrite1
0000c8  1c7f              ADDS     r7,r7,#1
0000ca  2fff              CMP      r7,#0xff              ;288
0000cc  d9f8              BLS      |L7.192|
;;;291    			}
;;;292    
;;;293    			sf_SetCS(1);								/* 禁止片选 */
0000ce  2001              MOVS     r0,#1
0000d0  f7fffffe          BL       sf_SetCS
;;;294    
;;;295    			sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
0000d4  f7fffffe          BL       sf_WaitForWriteEnd
0000d8  f1080801          ADD      r8,r8,#1              ;278
0000dc  f5057580          ADD      r5,r5,#0x100          ;278
                  |L7.224|
0000e0  ebb82f16          CMP      r8,r6,LSR #8          ;278
0000e4  d3d8              BCC      |L7.152|
                  |L7.230|
;;;296    
;;;297    			_uiWriteAddr += 256;
;;;298    		}
;;;299    
;;;300    		/* 进入写保护状态 */
;;;301    		sf_SetCS(0);
0000e6  2000              MOVS     r0,#0
0000e8  f7fffffe          BL       sf_SetCS
;;;302    		bsp_spiWrite1(CMD_DISWR);
0000ec  2004              MOVS     r0,#4
0000ee  f7fffffe          BL       bsp_spiWrite1
;;;303    		sf_SetCS(1);
0000f2  2001              MOVS     r0,#1
0000f4  f7fffffe          BL       sf_SetCS
;;;304    
;;;305    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
0000f8  e8bd41f0          POP      {r4-r8,lr}
0000fc  f7ffbffe          B.W      sf_WaitForWriteEnd
                  |L7.256|
;;;306    	}
;;;307    }
000100  e8bd81f0          POP      {r4-r8,pc}
;;;308    
                          ENDP

                  |L7.260|
                          DCD      ||.bss||
                  |L7.264|
                          DCD      0x00bf2541

                          AREA ||i.sf_ReadBuffer||, CODE, READONLY, ALIGN=2

                  sf_ReadBuffer PROC
;;;318    */
;;;319    void sf_ReadBuffer(uint8_t * _pBuf, uint32_t _uiReadAddr, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;320    {
000002  0014              MOVS     r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
000008  d021              BEQ      |L8.78|
;;;321    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;322    	if ((_uiSize == 0) ||(_uiReadAddr + _uiSize) > g_tSF.TotalSize)
00000a  4911              LDR      r1,|L8.80|
00000c  1928              ADDS     r0,r5,r4
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tSF
000010  4288              CMP      r0,r1
000012  d81c              BHI      |L8.78|
;;;323    	{
;;;324    		return;
;;;325    	}
;;;326    
;;;327    	/* 擦除扇区操作 */
;;;328    	sf_SetCS(0);									/* 使能片选 */
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       sf_SetCS
;;;329    	bsp_spiWrite1(CMD_READ);							/* 发送读命令 */
00001a  2003              MOVS     r0,#3
00001c  f7fffffe          BL       bsp_spiWrite1
;;;330    	bsp_spiWrite1((_uiReadAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000020  f3c54007          UBFX     r0,r5,#16,#8
000024  f7fffffe          BL       bsp_spiWrite1
;;;331    	bsp_spiWrite1((_uiReadAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000028  f3c52007          UBFX     r0,r5,#8,#8
00002c  f7fffffe          BL       bsp_spiWrite1
;;;332    	bsp_spiWrite1(_uiReadAddr & 0xFF);				/* 发送扇区地址低8bit */
000030  b2e8              UXTB     r0,r5
000032  f7fffffe          BL       bsp_spiWrite1
;;;333    	while (_uiSize--)
000036  e003              B        |L8.64|
                  |L8.56|
;;;334    	{
;;;335    		*_pBuf++ = bsp_spiRead1();			/* 读一个字节并存储到pBuf，读完后指针自加1 */
000038  f7fffffe          BL       bsp_spiRead1
00003c  f8060b01          STRB     r0,[r6],#1
                  |L8.64|
000040  1e64              SUBS     r4,r4,#1
000042  d2f9              BCS      |L8.56|
;;;336    	}
;;;337    	sf_SetCS(1);									/* 禁能片选 */
000044  e8bd4070          POP      {r4-r6,lr}
000048  2001              MOVS     r0,#1
00004a  f7ffbffe          B.W      sf_SetCS
                  |L8.78|
;;;338    }
00004e  bd70              POP      {r4-r6,pc}
;;;339    
                          ENDP

                  |L8.80|
                          DCD      ||.bss||

                          AREA ||i.sf_ReadID||, CODE, READONLY, ALIGN=1

                  sf_ReadID PROC
;;;651    */
;;;652    uint32_t sf_ReadID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;653    {
;;;654    	uint32_t uiID;
;;;655    	uint8_t id1, id2, id3;
;;;656    
;;;657    	sf_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       sf_SetCS
;;;658    	bsp_spiWrite1(CMD_RDID);								/* 发送读ID命令 */
000008  209f              MOVS     r0,#0x9f
00000a  f7fffffe          BL       bsp_spiWrite1
;;;659    	id1 = bsp_spiRead1();					/* 读ID的第1个字节 */
00000e  f7fffffe          BL       bsp_spiRead1
000012  4604              MOV      r4,r0
;;;660    	id2 = bsp_spiRead1();					/* 读ID的第2个字节 */
000014  f7fffffe          BL       bsp_spiRead1
000018  4605              MOV      r5,r0
;;;661    	id3 = bsp_spiRead1();					/* 读ID的第3个字节 */
00001a  f7fffffe          BL       bsp_spiRead1
00001e  4606              MOV      r6,r0
;;;662    	sf_SetCS(1);									/* 禁能片选 */
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       sf_SetCS
;;;663    
;;;664    	uiID = ((uint32_t)id1 << 16) | ((uint32_t)id2 << 8) | id3;
000026  0420              LSLS     r0,r4,#16
000028  ea402005          ORR      r0,r0,r5,LSL #8
00002c  4330              ORRS     r0,r0,r6
;;;665    
;;;666    	return uiID;
;;;667    }
00002e  bd70              POP      {r4-r6,pc}
;;;668    
                          ENDP


                          AREA ||i.sf_ReadInfo||, CODE, READONLY, ALIGN=2

                  sf_ReadInfo PROC
;;;676    */
;;;677    void sf_ReadInfo(void)
000000  b570              PUSH     {r4-r6,lr}
;;;678    {
;;;679    	/* 自动识别串行Flash型号 */
;;;680    	{
;;;681    		g_tSF.ChipID = sf_ReadID();	/* 芯片ID */
000002  f7fffffe          BL       sf_ReadID
000006  4c15              LDR      r4,|L10.92|
;;;682    
;;;683    		switch (g_tSF.ChipID)
000008  4915              LDR      r1,|L10.96|
;;;684    		{
;;;685    			case SST25VF016B_ID:
;;;686    				strcpy(g_tSF.ChipName, "SST25VF016B");
;;;687    				g_tSF.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
00000a  f44f1600          MOV      r6,#0x200000
00000e  6020              STR      r0,[r4,#0]            ;683  ; g_tSF
000010  1840              ADDS     r0,r0,r1              ;683
;;;688    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000012  f44f5580          MOV      r5,#0x1000
000016  d009              BEQ      |L10.44|
000018  4912              LDR      r1,|L10.100|
00001a  1840              ADDS     r0,r0,r1              ;683
00001c  d008              BEQ      |L10.48|
00001e  4912              LDR      r1,|L10.104|
000020  1840              ADDS     r0,r0,r1              ;683
000022  d00b              BEQ      |L10.60|
000024  2801              CMP      r0,#1                 ;683
000026  d010              BEQ      |L10.74|
;;;689    				break;
;;;690    
;;;691    			case MX25L1606E_ID:
;;;692    				strcpy(g_tSF.ChipName, "MX25L1606E");
;;;693    				g_tSF.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
;;;694    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
;;;695    				break;
;;;696    
;;;697    			case W25Q64_ID:
;;;698    				strcpy(g_tSF.ChipName, "W25Q64");
;;;699    				g_tSF.TotalSize = 8 * 1024 * 1024;	/* 总容量 = 8M */
;;;700    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
;;;701    				break;
;;;702    
;;;703    
;;;704    			case W25Q128_ID:
;;;705    				strcpy(g_tSF.ChipName, "W25Q128");
;;;706    				g_tSF.TotalSize = 16 * 1024 * 1024;	/* 总容量 = 16M */
;;;707    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
;;;708    				break;			
;;;709    
;;;710    			default:
;;;711    				strcpy(g_tSF.ChipName, "Unknow Flash");
000028  a110              ADR      r1,|L10.108|
;;;712    				g_tSF.TotalSize = 2 * 1024 * 1024;
;;;713    				g_tSF.PageSize = 4 * 1024;
;;;714    				break;
00002a  e002              B        |L10.50|
                  |L10.44|
00002c  a113              ADR      r1,|L10.124|
00002e  e000              B        |L10.50|
                  |L10.48|
000030  a115              ADR      r1,|L10.136|
                  |L10.50|
000032  1d20              ADDS     r0,r4,#4              ;686
000034  f7fffffe          BL       strcpy
000038  6166              STR      r6,[r4,#0x14]         ;687  ; g_tSF
00003a  e00d              B        |L10.88|
                  |L10.60|
00003c  a115              ADR      r1,|L10.148|
00003e  1d20              ADDS     r0,r4,#4              ;698
000040  f7fffffe          BL       strcpy
000044  f44f0000          MOV      r0,#0x800000          ;699
000048  e005              B        |L10.86|
                  |L10.74|
00004a  a114              ADR      r1,|L10.156|
00004c  1d20              ADDS     r0,r4,#4              ;705
00004e  f7fffffe          BL       strcpy
000052  f04f7080          MOV      r0,#0x1000000         ;706
                  |L10.86|
000056  6160              STR      r0,[r4,#0x14]         ;699  ; g_tSF
                  |L10.88|
000058  8325              STRH     r5,[r4,#0x18]         ;713
;;;715    		}
;;;716    	}
;;;717    }
00005a  bd70              POP      {r4-r6,pc}
;;;718    
                          ENDP

                  |L10.92|
                          DCD      ||.bss||
                  |L10.96|
                          DCD      0xff40dabf
                  |L10.100|
                          DCD      0xfffd052c
                  |L10.104|
                          DCD      0xffd2dffe
                  |L10.108|
00006c  556e6b6e          DCB      "Unknow Flash",0
000070  6f772046
000074  6c617368
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L10.124|
00007c  53535432          DCB      "SST25VF016B",0
000080  35564630
000084  31364200
                  |L10.136|
000088  4d583235          DCB      "MX25L1606E",0
00008c  4c313630
000090  364500  
000093  00                DCB      0
                  |L10.148|
000094  57323551          DCB      "W25Q64",0
000098  363400  
00009b  00                DCB      0
                  |L10.156|
00009c  57323551          DCB      "W25Q128",0
0000a0  31323800

                          AREA ||i.sf_SetCS||, CODE, READONLY, ALIGN=2

                  sf_SetCS PROC
;;;126    */
;;;127    static void sf_SetCS(uint8_t _level)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	if (_level == 0)
;;;130    	{
;;;131    		bsp_SpiBusEnter();	/* 占用SPI总线， 用于总线共享 */
;;;132    
;;;133    		#ifdef SOFT_SPI		/* 软件SPI */
;;;134    			bsp_SetSpiSck(1);
;;;135    			SF_CS_0();
;;;136    		#endif
;;;137    
;;;138    		#ifdef HARD_SPI		/* 硬件SPI */
;;;139    
;;;140    			bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
;;;141    				| SPI_CPOL_High | SPI_CPHA_2Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_8 | SPI_FirstBit_MSB);
;;;142    
;;;143    			SF_CS_0();
000002  f44f6400          MOV      r4,#0x800
000006  b128              CBZ      r0,|L11.20|
;;;144    		#endif
;;;145    	}
;;;146    	else
;;;147    	{
;;;148    		SF_CS_1();
000008  4807              LDR      r0,|L11.40|
00000a  6004              STR      r4,[r0,#0]
;;;149    
;;;150    		bsp_SpiBusExit();	/* 释放SPI总线， 用于总线共享 */
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      bsp_SpiBusExit
                  |L11.20|
000014  f7fffffe          BL       bsp_SpiBusEnter
000018  f2403017          MOV      r0,#0x317             ;140
00001c  f7fffffe          BL       bsp_SPI_Init
000020  4801              LDR      r0,|L11.40|
000022  1d00              ADDS     r0,r0,#4              ;143
000024  6004              STR      r4,[r0,#0]            ;143
;;;151    	}
;;;152    }
000026  bd10              POP      {r4,pc}
;;;153    
                          ENDP

                  |L11.40|
                          DCD      0x40011c10

                          AREA ||i.sf_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  sf_WaitForWriteEnd PROC
;;;774    */
;;;775    static void sf_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;776    {
;;;777    	sf_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       sf_SetCS
;;;778    	bsp_spiWrite1(CMD_RDSR);							/* 发送命令， 读状态寄存器 */
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       bsp_spiWrite1
;;;779    	while((bsp_spiRead1() & WIP_FLAG) == SET);	/* 判断状态寄存器的忙标志位 */
00000e  bf00              NOP      
                  |L12.16|
000010  f7fffffe          BL       bsp_spiRead1
000014  07c0              LSLS     r0,r0,#31
000016  d1fb              BNE      |L12.16|
;;;780    	sf_SetCS(1);									/* 禁能片选 */
000018  e8bd4010          POP      {r4,lr}
00001c  2001              MOVS     r0,#1
00001e  f7ffbffe          B.W      sf_SetCS
;;;781    }
;;;782    
                          ENDP


                          AREA ||i.sf_WriteBuffer||, CODE, READONLY, ALIGN=2

                  sf_WriteBuffer PROC
;;;543    */
;;;544    uint8_t sf_WriteBuffer(uint8_t* _pBuf, uint32_t _uiWriteAddr, uint16_t _usWriteSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;545    {
;;;546    	uint16_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
;;;547    
;;;548    	Addr = _uiWriteAddr % g_tSF.PageSize;
000004  f8df80d0          LDR      r8,|L13.216|
000008  4607              MOV      r7,r0                 ;545
00000a  460e              MOV      r6,r1                 ;545
00000c  f8b80018          LDRH     r0,[r8,#0x18]  ; g_tSF
000010  fbb1f1f0          UDIV     r1,r1,r0
000014  fb006111          MLS      r1,r0,r1,r6
000018  0409              LSLS     r1,r1,#16
00001a  0c09              LSRS     r1,r1,#16
;;;549    	count = g_tSF.PageSize - Addr;
00001c  eba00301          SUB      r3,r0,r1
000020  b29c              UXTH     r4,r3
;;;550    	NumOfPage =  _usWriteSize / g_tSF.PageSize;
;;;551    	NumOfSingle = _usWriteSize % g_tSF.PageSize;
000022  fbb2f3f0          UDIV     r3,r2,r0
000026  fbb2f5f0          UDIV     r5,r2,r0              ;550
00002a  fb002913          MLS      r9,r0,r3,r2
00002e  d014              BEQ      |L13.90|
;;;552    
;;;553    	if (Addr == 0) /* 起始地址是页面首地址  */
;;;554    	{
;;;555    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
;;;556    		{
;;;557    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
;;;558    			{
;;;559    				return 0;
;;;560    			}
;;;561    		}
;;;562    		else 	/* 数据长度大于等于页面大小 */
;;;563    		{
;;;564    			while (NumOfPage--)
;;;565    			{
;;;566    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, g_tSF.PageSize) == 0)
;;;567    				{
;;;568    					return 0;
;;;569    				}
;;;570    				_uiWriteAddr +=  g_tSF.PageSize;
;;;571    				_pBuf += g_tSF.PageSize;
;;;572    			}
;;;573    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;574    			{
;;;575    				return 0;
;;;576    			}
;;;577    		}
;;;578    	}
;;;579    	else  /* 起始地址不是页面首地址  */
;;;580    	{
;;;581    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
000030  b34d              CBZ      r5,|L13.134|
;;;582    		{
;;;583    			if (NumOfSingle > count) /* (_usWriteSize + _uiWriteAddr) > SPI_FLASH_PAGESIZE */
;;;584    			{
;;;585    				temp = NumOfSingle - count;
;;;586    
;;;587    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;588    				{
;;;589    					return 0;
;;;590    				}
;;;591    
;;;592    				_uiWriteAddr +=  count;
;;;593    				_pBuf += count;
;;;594    
;;;595    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, temp) == 0)
;;;596    				{
;;;597    					return 0;
;;;598    				}
;;;599    			}
;;;600    			else
;;;601    			{
;;;602    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
;;;603    				{
;;;604    					return 0;
;;;605    				}
;;;606    			}
;;;607    		}
;;;608    		else	/* 数据长度大于等于页面大小 */
;;;609    		{
;;;610    			_usWriteSize -= count;
000032  1b11              SUBS     r1,r2,r4
000034  b289              UXTH     r1,r1
;;;611    			NumOfPage =  _usWriteSize / g_tSF.PageSize;
;;;612    			NumOfSingle = _usWriteSize % g_tSF.PageSize;
000036  fbb1f2f0          UDIV     r2,r1,r0
00003a  fbb1f5f0          UDIV     r5,r1,r0              ;611
00003e  46c1              MOV      r9,r8                 ;611
000040  fb001812          MLS      r8,r0,r2,r1
;;;613    
;;;614    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
000044  4622              MOV      r2,r4
000046  4631              MOV      r1,r6
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       sf_AutoWritePage
00004e  2800              CMP      r0,#0
000050  d02d              BEQ      |L13.174|
;;;615    			{
;;;616    				return 0;
;;;617    			}
;;;618    
;;;619    			_uiWriteAddr +=  count;
000052  4426              ADD      r6,r6,r4
;;;620    			_pBuf += count;
000054  4427              ADD      r7,r7,r4
000056  464c              MOV      r4,r9                 ;548
;;;621    
;;;622    			while (NumOfPage--)
000058  e035              B        |L13.198|
                  |L13.90|
00005a  b97d              CBNZ     r5,|L13.124|
                  |L13.92|
00005c  4631              MOV      r1,r6                 ;557
00005e  4638              MOV      r0,r7                 ;557
000060  e020              B        |L13.164|
000062  bf00              NOP                            ;566
                  |L13.100|
000064  f8b82018          LDRH     r2,[r8,#0x18]         ;566  ; g_tSF
000068  4631              MOV      r1,r6                 ;566
00006a  4638              MOV      r0,r7                 ;566
00006c  f7fffffe          BL       sf_AutoWritePage
000070  2800              CMP      r0,#0                 ;566
000072  d01c              BEQ      |L13.174|
000074  f8b80018          LDRH     r0,[r8,#0x18]         ;570  ; g_tSF
000078  4406              ADD      r6,r6,r0              ;570
00007a  4407              ADD      r7,r7,r0              ;571
                  |L13.124|
00007c  1e6d              SUBS     r5,r5,#1              ;564
00007e  b2ad              UXTH     r5,r5                 ;564
000080  d2f0              BCS      |L13.100|
000082  464a              MOV      r2,r9                 ;573
000084  e7ea              B        |L13.92|
                  |L13.134|
000086  45a1              CMP      r9,r4                 ;583
000088  d9e8              BLS      |L13.92|
00008a  eba90004          SUB      r0,r9,r4              ;585
00008e  b285              UXTH     r5,r0                 ;585
000090  4622              MOV      r2,r4                 ;587
000092  4631              MOV      r1,r6                 ;587
000094  4638              MOV      r0,r7                 ;587
000096  f7fffffe          BL       sf_AutoWritePage
00009a  2800              CMP      r0,#0                 ;587
00009c  d007              BEQ      |L13.174|
00009e  1931              ADDS     r1,r6,r4              ;592
0000a0  1938              ADDS     r0,r7,r4              ;593
0000a2  462a              MOV      r2,r5                 ;595
                  |L13.164|
;;;623    			{
;;;624    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, g_tSF.PageSize) == 0)
;;;625    				{
;;;626    					return 0;
;;;627    				}
;;;628    				_uiWriteAddr +=  g_tSF.PageSize;
;;;629    				_pBuf += g_tSF.PageSize;
;;;630    			}
;;;631    
;;;632    			if (NumOfSingle != 0)
;;;633    			{
;;;634    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
0000a4  f7fffffe          BL       sf_AutoWritePage
0000a8  2800              CMP      r0,#0
0000aa  d000              BEQ      |L13.174|
                  |L13.172|
;;;635    				{
;;;636    					return 0;
;;;637    				}
;;;638    			}
;;;639    		}
;;;640    	}
;;;641    	return 1;	/* 成功 */
0000ac  2001              MOVS     r0,#1
                  |L13.174|
;;;642    }
0000ae  e8bd87f0          POP      {r4-r10,pc}
                  |L13.178|
0000b2  8b22              LDRH     r2,[r4,#0x18]         ;624  ; g_tSF
0000b4  4631              MOV      r1,r6                 ;624
0000b6  4638              MOV      r0,r7                 ;624
0000b8  f7fffffe          BL       sf_AutoWritePage
0000bc  2800              CMP      r0,#0                 ;624
0000be  d0f6              BEQ      |L13.174|
0000c0  8b20              LDRH     r0,[r4,#0x18]         ;628  ; g_tSF
0000c2  4406              ADD      r6,r6,r0              ;628
0000c4  4407              ADD      r7,r7,r0              ;629
                  |L13.198|
0000c6  1e6d              SUBS     r5,r5,#1              ;622
0000c8  b2ad              UXTH     r5,r5                 ;622
0000ca  d2f2              BCS      |L13.178|
0000cc  f1b80000          SUBS     r0,r8,#0              ;632
0000d0  d0ec              BEQ      |L13.172|
0000d2  4602              MOV      r2,r0                 ;634
0000d4  e7c2              B        |L13.92|
;;;643    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L13.216|
                          DCD      ||.bss||

                          AREA ||i.sf_WriteEnable||, CODE, READONLY, ALIGN=1

                  sf_WriteEnable PROC
;;;726    */
;;;727    static void sf_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;728    {
;;;729    	sf_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       sf_SetCS
;;;730    	bsp_spiWrite1(CMD_WREN);								/* 发送命令 */
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       bsp_spiWrite1
;;;731    	sf_SetCS(1);									/* 禁能片选 */
00000e  e8bd4010          POP      {r4,lr}
000012  2001              MOVS     r0,#1
000014  f7ffbffe          B.W      sf_SetCS
;;;732    }
;;;733    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tSF
                          %        28

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_spi_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_69e7dfca____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_spi_flash_c_69e7dfca____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_69e7dfca____REVSH|
#line 128
|__asm___15_bsp_spi_flash_c_69e7dfca____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
